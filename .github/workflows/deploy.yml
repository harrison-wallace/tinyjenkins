name: Deploy Jenkins
on:
  push:
    branches: [ main ]
jobs:
  terraform:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - uses: hashicorp/setup-terraform@v2
      with:
        terraform_version: 1.5.0
    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.TF_VAR_region }}
    - name: Verify AWS Credentials
      run: |
        IDENTITY=$(aws sts get-caller-identity)
        echo "AWS Account ID: $(echo $IDENTITY | jq -r .Account)"
        if [ "$(echo $IDENTITY | jq -r .Account)" != "398479486540" ]; then
          echo "Error: Expected AWS account 398479486540, got $(echo $IDENTITY | jq -r .Account)"
          exit 1
        fi
    - name: Verify S3 Bucket
      run: |
        aws s3api head-bucket --bucket ${{ secrets.TF_VAR_state_bucket }} || { echo "S3 bucket ${{ secrets.TF_VAR_state_bucket }} not found or inaccessible"; exit 1; }
        aws s3 ls s3://${{ secrets.TF_VAR_state_bucket }} || { echo "Cannot list S3 bucket ${{ secrets.TF_VAR_state_bucket }}"; exit 1; }
    - name: Verify Route 53 Hosted Zone
      run: |
        aws route53 list-hosted-zones-by-name --dns-name ${{ secrets.TF_VAR_domain_name }} | grep -q "HostedZone" || { echo "Route 53 hosted zone for ${{ secrets.TF_VAR_domain_name }} not found"; exit 1; }
    - name: Terraform Init
      run: terraform init -backend-config="bucket=${{ secrets.TF_VAR_state_bucket }}" -backend-config="region=${{ secrets.TF_VAR_region }}"
    - name: Terraform Plan
      env:
        TF_VAR_domain_name: ${{ secrets.TF_VAR_domain_name }}
        TF_VAR_state_bucket: ${{ secrets.TF_VAR_state_bucket }}
        TF_VAR_region: ${{ secrets.TF_VAR_region }}
        TF_VAR_key_name: ${{ secrets.TF_VAR_key_name }}
        TF_VAR_allowed_cidr: ${{ secrets.TF_VAR_allowed_cidr }}
        TF_VAR_alert_email: ${{ secrets.TF_VAR_alert_email }}
        TF_LOG: DEBUG
      timeout-minutes: 5
      run: terraform plan -out=tfplan -no-color
    - name: Terraform Apply
      if: github.ref == 'refs/heads/main'
      env:
        TF_VAR_domain_name: ${{ secrets.TF_VAR_domain_name }}
        TF_VAR_state_bucket: ${{ secrets.TF_VAR_state_bucket }}
        TF_VAR_region: ${{ secrets.TF_VAR_region }}
        TF_VAR_key_name: ${{ secrets.TF_VAR_key_name }}
        TF_VAR_allowed_cidr: ${{ secrets.TF_VAR_allowed_cidr }}
        TF_VAR_alert_email: ${{ secrets.TF_VAR_alert_email }}
      run: terraform apply -auto-approve tfplan
    - name: Mask Sensitive Outputs
      run: |
        echo "::add-mask::$(terraform output -raw jenkins_url)"
        echo "::add-mask::${{ secrets.TF_VAR_domain_name }}"
    - name: Get Instance ID and Wait for Running State
      run: |
        INSTANCE_ID=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=Jenkins-Spot" "Name=instance-state-name,Values=pending,running" --query 'Reservations[0].Instances[0].InstanceId' --output text --no-cli-pager)
        if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" == "None" ]; then
          echo "No running or pending instance found with tag Name=Jenkins-Spot"
          exit 1
        fi
        echo "INSTANCE_ID=$INSTANCE_ID" >> $GITHUB_ENV
        aws ec2 wait instance-running --instance-ids $INSTANCE_ID --no-cli-pager
    - name: Verify IAM Role
      run: |
        ROLE_ARN=$(terraform output -raw iam_role_arn)
        INSTANCE_PROFILE=$(aws ec2 describe-instances --instance-ids $INSTANCE_ID --query 'Reservations[0].Instances[0].IamInstanceProfile.Arn' --output text --no-cli-pager)
        echo "Role ARN: $ROLE_ARN"
        echo "Instance Profile ARN: $INSTANCE_PROFILE"
        # Extract role name from ROLE_ARN
        ROLE_NAME=$(echo $ROLE_ARN | awk -F'/' '{print $NF}')
        # Check if instance profile contains the role name
        if [[ "$INSTANCE_PROFILE" != *"$ROLE_NAME"* ]]; then
          echo "Error: IAM role $ROLE_ARN not associated with instance profile $INSTANCE_PROFILE for instance $INSTANCE_ID"
          exit 1
        fi
    - name: Check Instance Metadata Access
      run: |
        COMMAND_ID=$(aws ssm send-command \
          --instance-ids $INSTANCE_ID \
          --document-name "AWS-RunShellScript" \
          --parameters '{"commands": ["curl -s http://169.254.169.254/latest/meta-data/iam/security-credentials/ || echo Metadata access failed"]}' \
          --query 'Command.CommandId' \
          --output text --no-cli-pager || echo "SSM command to check metadata failed, continuing")
        if [ -n "$COMMAND_ID" ]; then
          sleep 10
          STATUS=$(aws ssm get-command-invocation --command-id $COMMAND_ID --instance-id $INSTANCE_ID --query 'Status' --output text --no-cli-pager)
          if [ "$STATUS" == "Success" ]; then
            OUTPUT=$(aws ssm get-command-invocation --command-id $COMMAND_ID --instance-id $INSTANCE_ID --query 'StandardOutputContent' --output text --no-cli-pager)
            echo "Metadata access output: $OUTPUT"
            if [[ "$OUTPUT" == *"Metadata access failed"* ]]; then
              echo "Error: Instance metadata service not accessible"
              exit 1
            fi
          else
            echo "SSM command to check metadata failed with status $STATUS"
          fi
        fi
    - name: Attempt to Restart SSM Agent
      run: |
        COMMAND_ID=$(aws ssm send-command \
          --instance-ids $INSTANCE_ID \
          --document-name "AWS-RunShellScript" \
          --parameters '{"commands": ["sudo systemctl restart amazon-ssm-agent"]}' \
          --query 'Command.CommandId' \
          --output text --no-cli-pager || echo "SSM command to restart agent failed, continuing")
        if [ -n "$COMMAND_ID" ]; then
          sleep 10
          for i in {1..3}; do
            STATUS=$(aws ssm get-command-invocation --command-id $COMMAND_ID --instance-id $INSTANCE_ID --query 'Status' --output text --no-cli-pager)
            if [ "$STATUS" == "Success" ]; then
              echo "SSM agent restarted successfully"
              break
            elif [ "$STATUS" == "Failed" ] || [ "$STATUS" == "Cancelled" ] || [ "$STATUS" == "TimedOut" ]; then
              echo "SSM agent restart failed with status $STATUS"
              break
            fi
            echo "Waiting for SSM agent restart to complete... Attempt $i"
            sleep 5
          done
        fi
    - name: Wait for SSM Agent
      run: |
        for i in {1..8}; do
          STATUS=$(aws ssm describe-instance-information --instance-information-filter-list "key=InstanceIds,valueSet=$INSTANCE_ID" --query 'InstanceInformationList[0].PingStatus' --output text --no-cli-pager)
          if [ "$STATUS" == "Online" ]; then
            echo "SSM agent is online"
            break
          fi
          echo "Waiting for SSM agent to be online... Attempt $i"
          sleep 15
          if [ $i -eq 8 ]; then
            echo "SSM agent not online after 8 attempts"
            aws ec2 get-console-output --instance-id $INSTANCE_ID --query 'Output' --output text --no-cli-pager > console_output.txt
            echo "Instance console output (last 1000 characters):"
            tail -c 1000 console_output.txt
            echo "SSM agent logs (last 20 lines):"
            echo "$SSH_PRIVATE_KEY" > key.pem
            chmod 600 key.pem
            scp -o StrictHostKeyChecking=no -i key.pem ec2-user@$(aws ec2 describe-instances --instance-ids $INSTANCE_ID --query 'Reservations[0].Instances[0].PublicIpAddress' --output text --no-cli-pager):/var/log/amazon-ssm-agent.log agent.log || echo "Failed to fetch SSM agent logs via SCP"
            tail -n 20 agent.log || echo "No agent logs available"
            exit 1
          fi
        done
      env:
        SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
    - name: Copy Ansible Playbooks via S3
      run: |
        # Zip playbooks
        zip -r playbooks.zip ansible/playbooks
        # Upload to S3
        aws s3 cp playbooks.zip s3://${{ secrets.TF_VAR_state_bucket }}/playbooks.zip
    - name: Execute Ansible Playbooks via SSM
      run: |
        # Send command to download and unzip playbooks, then run Ansible
        COMMAND_ID=$(aws ssm send-command \
          --instance-ids $INSTANCE_ID \
          --document-name "AWS-RunShellScript" \
          --parameters '{"commands": [
            "aws s3 cp s3://${{ secrets.TF_VAR_state_bucket }}/playbooks.zip /tmp/playbooks.zip",
            "unzip -o /tmp/playbooks.zip -d /tmp/",
            "sudo mv /tmp/ansible/playbooks /etc/ansible/",
            "sudo ansible-playbook /etc/ansible/jenkins.yml"
          ]}' \
          --query 'Command.CommandId' \
          --output text --no-cli-pager)
        # Wait for command to complete
        for i in {1..10}; do
          STATUS=$(aws ssm get-command-invocation --command-id $COMMAND_ID --instance-id $INSTANCE_ID --query 'Status' --output text --no-cli-pager)
          if [ "$STATUS" == "Success" ]; then
            echo "Ansible playbook executed successfully"
            break
          elif [ "$STATUS" == "Failed" ] || [ "$STATUS" == "Cancelled" ] || [ "$STATUS" == "TimedOut" ]; then
            echo "SSM command failed with status $STATUS"
            aws ssm get-command-invocation --command-id $COMMAND_ID --instance-id $INSTANCE_ID --query 'StandardErrorContent' --output text --no-cli-pager
            exit 1
          fi
          echo "Waiting for SSM command to complete... Attempt $i"
          sleep 10
        done